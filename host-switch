#!/bin/sh

HOSTS="/etc/hosts"

BEGIN_PATTERN="# begin"

MSG_HEAD="Local hosts setting"
MSG_ON="\e[1;32mON\e[m"
MSG_OFF="\e[1;31mOFF\e[m"


Usage()
{
    local exit_code=$1

    echo "Usage:"
    echo "     ${0##*/}                     show the cureent setting"
    echo "     ${0##*/} all-off <set>       turn off all local settings (Use DNS)"
    echo "     ${0##*/} on <set> <group>    to switch <group> hosts setting ON"
    echo ""

    if [ $exit_code -ge 0 ]; then
	exit $exit_code
    fi
}

check_root()
{
    if [ "`whoami`" != 'root' ]; then
	printf "Please execute again with \e[1;31mroot\e[m.\n"
	exit 1
    fi
}

#################################
# list operations
#################################

# return value:
# 0: found item in list
# -1: not found
in_list()
{
    local list_name=$1
    local entry=$2

    local list=''
    eval list=\$$list_name
    local is_found=0

    for item in ${list}; do
	if [ "$item" = "${entry}" ]; then
	    is_found=1
	    break
	fi
    done

    return $((${is_found} - 1))
}

list_add()
{
    local list_name=$1
    local entry=$2

    if in_list ${list_name} ${entry} ; then
        return
    fi

    local list=''
    eval list=\$$list_name

    if [ "$list" = '' ]; then
	eval $list_name="${entry}"
    else
	eval $list_name=\"${list} ${entry}\"
    fi
}

#################################
# validation
#################################

validate_set()
{
    local set=$1

    if [ -z "${set}" ]; then
	error "Please provide set name"
	return 1
    fi

    if ! in_list 'sets' "${set}" ; then
	error "Not a valid set name"
	return 1
    fi

    return 0
}

#################################
# Setting modifying functions
#################################

switch_off()
{
    local group=$1
    local is_output=$2

    local begin_tag="# begin ${group} host setting"
    local end_tag="# end ${group} host setting"

    if ! egrep -q "^${begin_tag}$" ${HOSTS}; then
	if [ "${is_output}" -eq 1 ]; then
	    printf "${MSG_HEAD} \e[33m${group}\e[m is already off\n"
	fi
    else
	sed -e "/${begin_tag}/,/${end_tag}/s/^/# /" -i "" ${HOSTS}
	if [ "${is_output}" -eq 1 ]; then
	    printf "${MSG_HEAD} \e[33m${group}\e[m is on, turn it ${MSG_OFF} now\n"
	fi
    fi
}

switch_on()
{
    local group=$1
    local is_output=$2

    local begin_tag="# begin ${group} host setting"
    local end_tag="# end ${group} host setting"

    if egrep -q "^${begin_tag}$" ${HOSTS}; then
	if [ "${is_output}" -eq 1 ]; then
	    printf "${MSG_HEAD} \e[33m${group}\e[m is already on\n"
	fi
    else
	sed -e "/${begin_tag}/,/${end_tag}/s/^# //" -i "" ${HOSTS}
	if [ "${is_output}" -eq 1 ]; then
	    printf "${MSG_HEAD} \e[33m${group}\e[m is off, turn it ${MSG_ON} now\n"
	fi
    fi
}

switch_off_set()
{
    local set=$1
    local except=$2

    for group in ${groups}; do
	if [ "$group" != "$except" ]; then
	    if echo ${group} | egrep -q "^${set}:"; then
		if egrep -q "^${BEGIN_PATTERN} ${group} host setting$" ${HOSTS}; then
		    switch_off ${group} 1
		fi
	    fi
	fi
    done
}

switch_all_off()
{
    local except=$1

    for group in ${groups}; do
	if [ "$group" != "$except" ]; then
	    if egrep -q "^${BEGIN_PATTERN} ${group} host setting$" ${HOSTS}; then
		switch_off ${group} 1
	    fi
	fi
    done
}

test_on_group_status()
{
    local group=$1
    local lookup=`egrep "${BEGIN_PATTERN} ${group} host setting$" ${HOSTS}`

    echo "${lookup}" | egrep -q "^${BEGIN_PATTERN}"
    return $?
}

test_set_setting()
{
    local set=$1
    local setting=""

    for group in `echo ${groups} | tr ' ' \\\n | egrep "^${set}:"`; do
	if test_on_group_status ${group}; then
	    setting="${group}"
	fi
    done

    echo ${setting}
}

#################################
# output setting functions
#################################

print_out_test_group()
{
    local group=$1

    if echo ${group} | grep -q ':'; then
	printf "   * \e[33m%s\e[m setting is " `echo ${group} | cut -d: -f 2`
    else
	printf "   * \e[33m%s\e[m setting is " ${group}
    fi

    if test_on_group_status ${group}; then
	printf "${MSG_ON}\n"
    else
	printf "${MSG_OFF}\n"
    fi
}

print_out_test_set()
{
    local set=$1
    printf " - set: \e[1;33;46m ${set} \e[m\n"
    for group in `echo ${groups} | tr ' ' \\\n | egrep "^${set}:"`; do
	print_out_test_group ${group}
    done
}

print_out_setting()
{
    for set in ${sets}; do
	print_out_test_set ${set}
    done

    local uncategorized=`echo ${groups} | tr ' ' \\\n | grep -v ':'`
    if [ ! -z "${uncategorized}" ]; then
	printf " - \e[1;35muncategorized\e[m\n"
	for group in ${uncategorized}; do
	    print_out_test_group ${group}
	done
    fi
}

look_up_group()
{
    local is_output=$1

    local setting_line=`grep "${BEGIN_PATTERN}" ${HOSTS}`
    for word in ${setting_line}; do
	if ! echo "${word}" | egrep -q "^(#|begin|host|setting)$" ; then
	    list_add 'groups' $word

	    # collect sets information
	    if echo "${word}" | grep -q ':'; then
		local set=`echo ${word} | cut -d: -f 1`
		list_add 'sets' $set
	    fi
	fi
    done

    if [ "${is_output}" -eq 1 ]; then
	print_out_setting
    fi
}

error()
{
    local msg=$1
    printf "\e[1;31mError\e[m: "
    echo "$msg"
}

#################################
# shell implementations
#################################

shell_parse()
{
    if [ "$1" = 'clear' -o "$1" = 'cls' ]; then
	clear
    elif [ "$1" = 'list' ]; then
	print_out_setting
    elif [ "$1" = 'help' ]; then
	Usage -1
    else
	echo ' => Not implemented'
    fi
}

shell_input()
{
    while true; do
	read -p 'host-switch >> ' input

	if [ $? -eq 1 ]; then
	    echo    # force newline
	    exit 0
	fi

	if [ "$input" = 'exit' -o "$input" = 'quit' ]; then
	    exit 0
	fi

	if [ -z "$input" ]; then
	    continue
	fi

	# do something
	shell_parse $input
    done
}

#################################
# main routine
#################################

main()
{
    # initialize
    if [ "$1" = '-h' -o "$1" = '--help' -o "$1" = 'help' ]; then
	Usage 0
    else
	look_up_group 0
    fi

    # list/show operation
    if [ "$1" = '' ]; then
	print_out_setting
	exit 0
    elif [ "$1" = 'show' -o "$1" = 'list' ]; then
	if [ "$2" = '' ]; then
	    print_out_setting
	    exit 0
	else
	    print_out_test_set $2
	    exit 0
	fi
    elif [ "$1" != 'all-off' -a "$1" != 'on' -a "$1" != 'shell' ]; then
	Usage 1
    else
	check_root
    fi

    # The process should have "$1" when they come to here.
    # options:
    #   all-off     use default external DNS record
    #   shell       interactive selection
    #   on xxx	switch on xxx, and turn off any other records

    if [ "$1" = "all-off" ]; then
	if ! validate_set "$2"; then
	    exit 1
	fi

	#switch_all_off ""
	switch_off_set "$2" ""
	printf "Set \e[1;33;46m ${2} \e[m "
	echo "is using global DNS setting now"
    elif [ "$1" = "on" ]; then
	# we need to parse "$2" here, to see if its a valid record name in the $HOSTS file
	if [ -z "$2" ]; then
	    error "Please provide group name"
	    exit 1
	fi

	local query_group=$2
	if [ ! -z "$3" ]; then
	    query_group="${2}:${3}"
	fi

	if ! in_list 'groups' "${query_group}" ; then
	    error "Not a valid group name"
	    exit 1
	fi

	if [ ! -z "$3" ]; then
	    switch_off_set "$2" "${query_group}"
	#else
	#    switch_all_off "$2"
	fi

	switch_on "${query_group}" 1
    elif [ "$1" = "shell" ]; then
	# interactive mode
	shell_input
    else
	# should not go here
	error "Fatal error"
	exit 1
    fi
}


# global variables
sets=""
groups=""

main $@
