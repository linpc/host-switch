#!/bin/sh

HOSTS="/etc/hosts"

BEGIN_PATTERN="# begin"

MSG_HEAD="Local hosts setting"
MSG_ON="\e[1;32mON\e[m"
MSG_OFF="\e[1;31mOFF\e[m"


Usage()
{
    local exit_code=$1

    echo "Usage:"
    echo "     ${0##*/}                     show the cureent setting"
    echo "     ${0##*/} all-off             turn off all local settings (Use DNS)"
    echo "     ${0##*/} on <group>          to switch <group> hosts setting ON"
    echo ""

    if [ $exit_code -ge 0 ]; then
	exit $exit_code
    fi
}

check_root()
{
    if [ "`whoami`" != 'root' ]; then
	printf "Please execute again with \e[1;31mroot\e[m.\n"
	exit 1
    fi
}

#################################
# list operations
#################################

# return value:
# 0: found item in list
# -1: not found
in_list()
{
    local list_name=$1
    local entry=$2

    local list=''
    eval list=\$$list_name
    local is_found=0

    for item in ${list}; do
	if [ "$item" = "${entry}" ]; then
	    is_found=1
	    break
	fi
    done

    return $((${is_found} - 1))
}

list_add()
{
    local list_name=$1
    local entry=$2

    if in_list ${list_name} ${entry} ; then
        return
    fi

    local list=''
    eval list=\$$list_name

    if [ "$list" = '' ]; then
	eval $list_name="${entry}"
    else
	eval $list_name=\"${list} ${entry}\"
    fi
}

#################################
# Setting modifying functions
#################################

switch_off()
{
    local group=$1
    local is_output=$2

    local begin_tag="# begin ${group} host setting"
    local end_tag="# end ${group} host setting"

    if ! egrep -q "^${begin_tag}$" ${HOSTS}; then
	if [ "${is_output}" -eq 1 ]; then
	    printf "${MSG_HEAD} \e[33m${group}\e[m is already off\n"
	fi
    else
	sed -e "/${begin_tag}/,/${end_tag}/s/^/# /" -i "" ${HOSTS}
	if [ "${is_output}" -eq 1 ]; then
	    printf "${MSG_HEAD} \e[33m${group}\e[m is on, turn it ${MSG_OFF} now\n"
	fi
    fi
}

switch_on()
{
    local group=$1
    local is_output=$2

    local begin_tag="# begin ${group} host setting"
    local end_tag="# end ${group} host setting"

    if egrep -q "^${begin_tag}$" ${HOSTS}; then
	if [ "${is_output}" -eq 1 ]; then
	    printf "${MSG_HEAD} \e[33m${group}\e[m is already on\n"
	fi
    else
	sed -e "/${begin_tag}/,/${end_tag}/s/^# //" -i "" ${HOSTS}
	if [ "${is_output}" -eq 1 ]; then
	    printf "${MSG_HEAD} \e[33m${group}\e[m is off, turn it ${MSG_ON} now\n"
	fi
    fi
}

switch_all_off()
{
    local except=$1

    for group in ${groups}; do
	if [ "$group" != "$except" ]; then
	    if egrep -q "^${BEGIN_PATTERN} ${group} host setting$" ${HOSTS}; then
		switch_off ${group} 1
	    fi
	fi
    done
}

#################################
# output setting functions
#################################

print_out_test_group()
{
    local group=$1

    if echo ${group} | grep -q ':'; then
	printf "   * \e[33m%s\e[m setting is " `echo ${group} | cut -d: -f 2`
    else
	printf "   * \e[33m%s\e[m setting is " ${group}
    fi
    local lookup=`egrep "${BEGIN_PATTERN} $1 host setting$" ${HOSTS}`
    if echo "${lookup}" | egrep -q "^# ${BEGIN_PATTERN}" ; then
	printf "${MSG_OFF}\n"
    else
	printf "${MSG_ON}\n"
    fi
}

print_out_test_set()
{
    local set=$1
    printf " - set: \e[1;35m${set}\e[m\n"
    for group in `echo ${groups} | tr ' ' \\\n | egrep "^${set}:"`; do
	print_out_test_group ${group}
    done
}

print_out_setting()
{
    for set in ${sets}; do
	print_out_test_set ${set}
    done

    local uncategorized=`echo ${groups} | tr ' ' \\\n | grep -v ':'`
    if [ ! -z "${uncategorized}" ]; then
	printf " - \e[1;35muncategorized\e[m\n"
	for group in ${uncategorized}; do
	    print_out_test_group ${group}
	done
    fi
}

look_up_group()
{
    local is_output=$1

    local setting_line=`grep "${BEGIN_PATTERN}" ${HOSTS}`
    for word in ${setting_line}; do
	if ! echo "${word}" | egrep -q "^(#|begin|host|setting)$" ; then
	    list_add 'groups' $word

	    # collect sets information
	    if echo "${word}" | grep -q ':'; then
		local set=`echo ${word} | cut -d: -f 1`
		list_add 'sets' $set
	    fi
	fi
    done

    if [ "${is_output}" -eq 1 ]; then
	print_out_setting
    fi
}

error()
{
    local msg=$1
    printf "\e[1;31mError\e[m: "
    echo "$msg"
}

#################################
# shell implementations
#################################

shell_parse()
{
    if [ "$1" = 'clear' -o "$1" = 'cls' ]; then
	clear
    elif [ "$1" = 'list' ]; then
	print_out_setting
    elif [ "$1" = 'help' ]; then
	Usage -1
    else
	echo ' => Not implemented'
    fi
}

shell_input()
{
    while true; do
	read -p 'host-switch >> ' input

	if [ $? -eq 1 ]; then
	    echo    # force newline
	    exit 0
	fi

	if [ "$input" = 'exit' -o "$input" = 'quit' ]; then
	    exit 0
	fi

	if [ -z "$input" ]; then
	    continue
	fi

	# do something
	shell_parse $input
    done
}

#################################
# main routine
#################################

# global variables
sets=""
groups=""

# initialize
if [ "$1" = '-h' -o "$1" = '--help' -o "$1" = 'help' ]; then
    Usage 0
else
    look_up_group 0
fi

# list/show operation
if [ "$1" = '' ]; then
    print_out_setting
    exit 0
elif [ "$1" = 'show' -o "$1" = 'list' ]; then
    if [ "$2" = '' ]; then
	print_out_setting
	exit 0
    else
	print_out_test_set $2
	exit 0
    fi
elif [ "$1" != 'all-off' -a "$1" != 'on' -a "$1" != 'shell' ]; then
    Usage 1
else
#    check_root
    printf ""
fi

# The process should have "$1" when they come to here.
# options:
#   all-off     use default external DNS record
#   shell       interactive selection
#   on xxx	switch on xxx, and turn off any other records

if [ "$1" = "all-off" ]; then
    switch_all_off ""
    echo "Use global DNS setting now"
elif [ "$1" = "on" ]; then
    # we need to parse "$2" here, to see if its a valid record name in the $HOSTS file
    if [ -z "$2" ]; then
	error "Please provide group name"
	exit 1
    fi
    if ! in_list 'groups' "$2" ; then
	error "Not a valid group name"
	exit 1
    fi
    switch_all_off "$2"
    switch_on "$2" 1
elif [ "$1" = "shell" ]; then
    # interactive mode
    shell_input
else
    # should not go here
    error "Fatal error"
    exit 1
fi
